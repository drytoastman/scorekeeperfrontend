/*
 * Docker Engine API
 * The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don't break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.44) is used. For example, calling `/info` is the same as calling `/v1.44/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 
 *
 * OpenAPI spec version: 1.44
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package org.wwscc.system.docker.models;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.wwscc.system.docker.models.EndpointIPAMConfig;

/**
 * Configuration for a network endpoint.
 */
@ApiModel(description = "Configuration for a network endpoint.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2025-12-27T04:16:08.747Z")
public class EndpointSettings {
  @JsonProperty("IPAMConfig")
  private EndpointIPAMConfig ipAMConfig = null;

  @JsonProperty("Links")
  private List<String> links = null;

  @JsonProperty("MacAddress")
  private String macAddress = null;

  @JsonProperty("Aliases")
  private List<String> aliases = null;

  @JsonProperty("NetworkID")
  private String networkID = null;

  @JsonProperty("EndpointID")
  private String endpointID = null;

  @JsonProperty("Gateway")
  private String gateway = null;

  @JsonProperty("IPAddress")
  private String ipAddress = null;

  @JsonProperty("IPPrefixLen")
  private Integer ipPrefixLen = null;

  @JsonProperty("IPv6Gateway")
  private String ipv6Gateway = null;

  @JsonProperty("GlobalIPv6Address")
  private String globalIPv6Address = null;

  @JsonProperty("GlobalIPv6PrefixLen")
  private Long globalIPv6PrefixLen = null;

  @JsonProperty("DriverOpts")
  private Map<String, String> driverOpts = null;

  @JsonProperty("DNSNames")
  private List<String> dnSNames = null;

  public EndpointSettings ipAMConfig(EndpointIPAMConfig ipAMConfig) {
    this.ipAMConfig = ipAMConfig;
    return this;
  }

   /**
   * Get ipAMConfig
   * @return ipAMConfig
  **/
  @ApiModelProperty(value = "")
  public EndpointIPAMConfig getIpAMConfig() {
    return ipAMConfig;
  }

  public void setIpAMConfig(EndpointIPAMConfig ipAMConfig) {
    this.ipAMConfig = ipAMConfig;
  }

  public EndpointSettings links(List<String> links) {
    this.links = links;
    return this;
  }

  public EndpointSettings addLinksItem(String linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @ApiModelProperty(example = "[\"container_1\",\"container_2\"]", value = "")
  public List<String> getLinks() {
    return links;
  }

  public void setLinks(List<String> links) {
    this.links = links;
  }

  public EndpointSettings macAddress(String macAddress) {
    this.macAddress = macAddress;
    return this;
  }

   /**
   * MAC address for the endpoint on this network. The network driver might ignore this parameter. 
   * @return macAddress
  **/
  @ApiModelProperty(example = "02:42:ac:11:00:04", value = "MAC address for the endpoint on this network. The network driver might ignore this parameter. ")
  public String getMacAddress() {
    return macAddress;
  }

  public void setMacAddress(String macAddress) {
    this.macAddress = macAddress;
  }

  public EndpointSettings aliases(List<String> aliases) {
    this.aliases = aliases;
    return this;
  }

  public EndpointSettings addAliasesItem(String aliasesItem) {
    if (this.aliases == null) {
      this.aliases = new ArrayList<>();
    }
    this.aliases.add(aliasesItem);
    return this;
  }

   /**
   * Get aliases
   * @return aliases
  **/
  @ApiModelProperty(example = "[\"server_x\",\"server_y\"]", value = "")
  public List<String> getAliases() {
    return aliases;
  }

  public void setAliases(List<String> aliases) {
    this.aliases = aliases;
  }

  public EndpointSettings networkID(String networkID) {
    this.networkID = networkID;
    return this;
  }

   /**
   * Unique ID of the network. 
   * @return networkID
  **/
  @ApiModelProperty(example = "08754567f1f40222263eab4102e1c733ae697e8e354aa9cd6e18d7402835292a", value = "Unique ID of the network. ")
  public String getNetworkID() {
    return networkID;
  }

  public void setNetworkID(String networkID) {
    this.networkID = networkID;
  }

  public EndpointSettings endpointID(String endpointID) {
    this.endpointID = endpointID;
    return this;
  }

   /**
   * Unique ID for the service endpoint in a Sandbox. 
   * @return endpointID
  **/
  @ApiModelProperty(example = "b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b", value = "Unique ID for the service endpoint in a Sandbox. ")
  public String getEndpointID() {
    return endpointID;
  }

  public void setEndpointID(String endpointID) {
    this.endpointID = endpointID;
  }

  public EndpointSettings gateway(String gateway) {
    this.gateway = gateway;
    return this;
  }

   /**
   * Gateway address for this network. 
   * @return gateway
  **/
  @ApiModelProperty(example = "172.17.0.1", value = "Gateway address for this network. ")
  public String getGateway() {
    return gateway;
  }

  public void setGateway(String gateway) {
    this.gateway = gateway;
  }

  public EndpointSettings ipAddress(String ipAddress) {
    this.ipAddress = ipAddress;
    return this;
  }

   /**
   * IPv4 address. 
   * @return ipAddress
  **/
  @ApiModelProperty(example = "172.17.0.4", value = "IPv4 address. ")
  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }

  public EndpointSettings ipPrefixLen(Integer ipPrefixLen) {
    this.ipPrefixLen = ipPrefixLen;
    return this;
  }

   /**
   * Mask length of the IPv4 address. 
   * @return ipPrefixLen
  **/
  @ApiModelProperty(example = "16", value = "Mask length of the IPv4 address. ")
  public Integer getIpPrefixLen() {
    return ipPrefixLen;
  }

  public void setIpPrefixLen(Integer ipPrefixLen) {
    this.ipPrefixLen = ipPrefixLen;
  }

  public EndpointSettings ipv6Gateway(String ipv6Gateway) {
    this.ipv6Gateway = ipv6Gateway;
    return this;
  }

   /**
   * IPv6 gateway address. 
   * @return ipv6Gateway
  **/
  @ApiModelProperty(example = "2001:db8:2::100", value = "IPv6 gateway address. ")
  public String getIpv6Gateway() {
    return ipv6Gateway;
  }

  public void setIpv6Gateway(String ipv6Gateway) {
    this.ipv6Gateway = ipv6Gateway;
  }

  public EndpointSettings globalIPv6Address(String globalIPv6Address) {
    this.globalIPv6Address = globalIPv6Address;
    return this;
  }

   /**
   * Global IPv6 address. 
   * @return globalIPv6Address
  **/
  @ApiModelProperty(example = "2001:db8::5689", value = "Global IPv6 address. ")
  public String getGlobalIPv6Address() {
    return globalIPv6Address;
  }

  public void setGlobalIPv6Address(String globalIPv6Address) {
    this.globalIPv6Address = globalIPv6Address;
  }

  public EndpointSettings globalIPv6PrefixLen(Long globalIPv6PrefixLen) {
    this.globalIPv6PrefixLen = globalIPv6PrefixLen;
    return this;
  }

   /**
   * Mask length of the global IPv6 address. 
   * @return globalIPv6PrefixLen
  **/
  @ApiModelProperty(example = "64", value = "Mask length of the global IPv6 address. ")
  public Long getGlobalIPv6PrefixLen() {
    return globalIPv6PrefixLen;
  }

  public void setGlobalIPv6PrefixLen(Long globalIPv6PrefixLen) {
    this.globalIPv6PrefixLen = globalIPv6PrefixLen;
  }

  public EndpointSettings driverOpts(Map<String, String> driverOpts) {
    this.driverOpts = driverOpts;
    return this;
  }

  public EndpointSettings putDriverOptsItem(String key, String driverOptsItem) {
    if (this.driverOpts == null) {
      this.driverOpts = new HashMap<>();
    }
    this.driverOpts.put(key, driverOptsItem);
    return this;
  }

   /**
   * DriverOpts is a mapping of driver options and values. These options are passed directly to the driver and are driver specific. 
   * @return driverOpts
  **/
  @ApiModelProperty(example = "{\"com.example.some-label\":\"some-value\",\"com.example.some-other-label\":\"some-other-value\"}", value = "DriverOpts is a mapping of driver options and values. These options are passed directly to the driver and are driver specific. ")
  public Map<String, String> getDriverOpts() {
    return driverOpts;
  }

  public void setDriverOpts(Map<String, String> driverOpts) {
    this.driverOpts = driverOpts;
  }

  public EndpointSettings dnSNames(List<String> dnSNames) {
    this.dnSNames = dnSNames;
    return this;
  }

  public EndpointSettings addDnSNamesItem(String dnSNamesItem) {
    if (this.dnSNames == null) {
      this.dnSNames = new ArrayList<>();
    }
    this.dnSNames.add(dnSNamesItem);
    return this;
  }

   /**
   * List of all DNS names an endpoint has on a specific network. This list is based on the container name, network aliases, container short ID, and hostname.  These DNS names are non-fully qualified but can contain several dots. You can get fully qualified DNS names by appending &#x60;.&lt;network-name&gt;&#x60;. For instance, if container name is &#x60;my.ctr&#x60; and the network is named &#x60;testnet&#x60;, &#x60;DNSNames&#x60; will contain &#x60;my.ctr&#x60; and the FQDN will be &#x60;my.ctr.testnet&#x60;. 
   * @return dnSNames
  **/
  @ApiModelProperty(example = "[\"foobar\",\"server_x\",\"server_y\",\"my.ctr\"]", value = "List of all DNS names an endpoint has on a specific network. This list is based on the container name, network aliases, container short ID, and hostname.  These DNS names are non-fully qualified but can contain several dots. You can get fully qualified DNS names by appending `.<network-name>`. For instance, if container name is `my.ctr` and the network is named `testnet`, `DNSNames` will contain `my.ctr` and the FQDN will be `my.ctr.testnet`. ")
  public List<String> getDnSNames() {
    return dnSNames;
  }

  public void setDnSNames(List<String> dnSNames) {
    this.dnSNames = dnSNames;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EndpointSettings endpointSettings = (EndpointSettings) o;
    return Objects.equals(this.ipAMConfig, endpointSettings.ipAMConfig) &&
        Objects.equals(this.links, endpointSettings.links) &&
        Objects.equals(this.macAddress, endpointSettings.macAddress) &&
        Objects.equals(this.aliases, endpointSettings.aliases) &&
        Objects.equals(this.networkID, endpointSettings.networkID) &&
        Objects.equals(this.endpointID, endpointSettings.endpointID) &&
        Objects.equals(this.gateway, endpointSettings.gateway) &&
        Objects.equals(this.ipAddress, endpointSettings.ipAddress) &&
        Objects.equals(this.ipPrefixLen, endpointSettings.ipPrefixLen) &&
        Objects.equals(this.ipv6Gateway, endpointSettings.ipv6Gateway) &&
        Objects.equals(this.globalIPv6Address, endpointSettings.globalIPv6Address) &&
        Objects.equals(this.globalIPv6PrefixLen, endpointSettings.globalIPv6PrefixLen) &&
        Objects.equals(this.driverOpts, endpointSettings.driverOpts) &&
        Objects.equals(this.dnSNames, endpointSettings.dnSNames);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ipAMConfig, links, macAddress, aliases, networkID, endpointID, gateway, ipAddress, ipPrefixLen, ipv6Gateway, globalIPv6Address, globalIPv6PrefixLen, driverOpts, dnSNames);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EndpointSettings {\n");
    
    sb.append("    ipAMConfig: ").append(toIndentedString(ipAMConfig)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    macAddress: ").append(toIndentedString(macAddress)).append("\n");
    sb.append("    aliases: ").append(toIndentedString(aliases)).append("\n");
    sb.append("    networkID: ").append(toIndentedString(networkID)).append("\n");
    sb.append("    endpointID: ").append(toIndentedString(endpointID)).append("\n");
    sb.append("    gateway: ").append(toIndentedString(gateway)).append("\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    ipPrefixLen: ").append(toIndentedString(ipPrefixLen)).append("\n");
    sb.append("    ipv6Gateway: ").append(toIndentedString(ipv6Gateway)).append("\n");
    sb.append("    globalIPv6Address: ").append(toIndentedString(globalIPv6Address)).append("\n");
    sb.append("    globalIPv6PrefixLen: ").append(toIndentedString(globalIPv6PrefixLen)).append("\n");
    sb.append("    driverOpts: ").append(toIndentedString(driverOpts)).append("\n");
    sb.append("    dnSNames: ").append(toIndentedString(dnSNames)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

